{
  "version": 3,
  "sources": ["src/stores/pipeline.ts"],
  "sourcesContent": ["import type {Readable} from \"svelte/store\";\n\nexport enum PIPELINE_RESULT_TYPES {\n    error = \"RESULT_ERROR\",\n\n    success = \"RESULT_SUCCESS\",\n}\n\nexport type IPipelineEvalutated = () => any;\n\nexport type IPipelineRequire = (name: string) => any;\n\nexport type IPipelineUpdater = (value: string) => string;\n\nexport interface IPipelineContext {\n    [key: string]: any;\n}\n\nexport interface IPipelineImports {\n    [key: string]: any;\n}\n\nexport interface IPipelineModule<T = any> {\n    exports: T;\n}\n\nexport interface IPipelineOptions {\n    context: IPipelineContext;\n\n    imports: IPipelineImports;\n}\n\nexport interface IPipelineResult {\n    type: PIPELINE_RESULT_TYPES;\n}\n\nexport interface IPipelineError extends IPipelineResult {\n    message: string;\n\n    type: PIPELINE_RESULT_TYPES.error;\n}\n\nexport interface IPipelineSuccess<T> extends IPipelineResult {\n    module: IPipelineModule<T>;\n\n    type: PIPELINE_RESULT_TYPES.success;\n}\n\n// HACK: Since the `Writable` uses the `T` generic for I/O on `set` / `update`, we\n// need to just redefine it here ourselves\nexport interface IPipelineStore<T> extends Readable<IPipelineError | IPipelineSuccess<T> | null> {\n    set(value: string): void;\n\n    update(updater: IPipelineUpdater): void;\n}\n\nexport function evaluate_code<T = any>(\n    script: string,\n    context: IPipelineContext\n): IPipelineModule<T> {\n    const keys = Object.keys(context);\n    const values = Object.values(context);\n\n    // @ts-ignore\n    const module: IPipelineModule<T> = {exports: {}};\n\n    Object.seal(module);\n\n    const func = new Function(\n        ...keys,\n        \"module\",\n        \"exports\",\n        `return (function () {\n        \"use strict\";\n        ${script}\n})`\n    )(...values, module, module.exports);\n\n    func();\n    return module;\n}\n\nexport function make_require(imports: IPipelineImports = {}): IPipelineRequire {\n    return (name) => {\n        if (name in imports) return imports[name];\n        throw new ReferenceError(\"bad argument #0 to 'require' (module '${name}' not found)\");\n    };\n}\n\nexport function validate_code(script: string): [boolean, string?] {\n    try {\n        new Function(script);\n    } catch (err) {\n        return [false, err.message];\n    }\n\n    return [true];\n}\n"],
  "mappings": "AAEO,IAAK;AAAL,UAAK;AACR,oCAAQ;AAER,sCAAU;AAAA,GAHF;AAsDL,uBACH,QACA;AAEA,QAAM,OAAO,OAAO,KAAK;AACzB,QAAM,SAAS,OAAO,OAAO;AAG7B,QAAM,SAA6B,CAAC,SAAS;AAE7C,SAAO,KAAK;AAEZ,QAAM,OAAO,IAAI,SACb,GAAG,MACH,UACA,WACA;AAAA;AAAA,UAEE;AAAA,KAEJ,GAAG,QAAQ,QAAQ,OAAO;AAE5B;AACA,SAAO;AAAA;AAGJ,sBAAsB,UAA4B;AACrD,SAAO,CAAC;AACJ,QAAI,QAAQ;AAAS,aAAO,QAAQ;AACpC,UAAM,IAAI,eAAe;AAAA;AAAA;AAI1B,uBAAuB;AAC1B;AACI,QAAI,SAAS;AAAA,WACR;AACL,WAAO,CAAC,OAAO,IAAI;AAAA;AAGvB,SAAO,CAAC;AAAA;",
  "names": []
}
