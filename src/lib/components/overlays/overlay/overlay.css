.overlay {
    display: block;
    position: fixed;

    inset: 0;

    z-index: 2;
}

.overlay > .backdrop {
    pointer-events: auto;
}

.overlay > section {
    --orientation-direction: column;

    --orientation-align: var(--flex-alignment-x);
    --orientation-justify: var(--flex-alignment-y);

    --flex-alignment-x: center;
    --flex-alignment-y: center;

    --spacing-x: 0;
    --spacing-y: 0;

    display: flex;
    position: absolute;

    flex-direction: var(--orientation-direction);
    gap: var(--spacing-y) var(--spacing-x);

    align-items: var(--orientation-align);
    justify-content: var(--orientation-justify);

    inset: 0;

    &.transition > * {
        /**
         * HACK: Using a `visibility` CSS property animation to create a hacky way of
         * skipping the first animation on first load
         */
        animation: visibility-hack 0.01s forwards paused;
    }

    & > * {
        pointer-events: auto;
    }
}

.overlay,
.overlay > section {
    /** HACK: `@keyframes` settings override this, we need to use `!important` to prevent that */
    pointer-events: none !important;
}

input[type="checkbox"][role="presentation"] {
    &:not(:checked) + .overlay {
        & > .backdrop {
            opacity: 0;
        }

        & > .transition {
            /**
             * HACK: We're abusing `Transition` Component's internal state CSS vars to
             * make`Overlay` transitions SSR-able
             */
            --animation: var(--animation-exit);
        }

        & > .backdrop,
        & > section > * {
            pointer-events: none;
        }
    }

    &:checked + .overlay {
        & > section > * {
            animation-play-state: running;
        }

        & > .transition {
            /**
             * HACK: We're abusing `Transition` Component's internal state CSS vars to
             * make`Overlay` transitions SSR-able
             */
            --animation: var(--animation-enter);
        }
    }
}
